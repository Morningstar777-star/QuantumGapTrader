{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ecdf2baa-1b41-446e-9aaf-aa73440f623b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import backtrader as bt\n",
    "import polars as pl\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import numpy as np\n",
    "import glob\n",
    "import os\n",
    "from datetime import datetime\n",
    "from typing import List, Tuple, Optional, Dict\n",
    "import cProfile\n",
    "import pstats\n",
    "import logging\n",
    "import sys\n",
    "from tqdm import tqdm\n",
    "\n",
    "# Configure logging\n",
    "logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n",
    "logger = logging.getLogger(__name__)\n",
    "\n",
    "# Configuration\n",
    "CONFIG = {\n",
    "    'csv_directory': r'C:\\Users\\Yash\\Desktop\\Equity - Apr 2015 - Mar 2025\\day',\n",
    "    'capital_per_trade': 10000,\n",
    "    'min_gap_pct': 2.0,\n",
    "    'initial_cash': 1000000,\n",
    "    'commission': 0.0,\n",
    "    'date_format': '%Y-%m-%dT%H:%M:%S%z',\n",
    "    'circuit_limit': 0.20,  # 20% circuit limit\n",
    "    'start_date': '2019-01-01',\n",
    "    'end_date': '2025-12-31',\n",
    "    'plot_config': {\n",
    "        'cumulative': {\n",
    "            'figsize': (10, 6),\n",
    "            'title': 'Cumulative Profit Over Time - {}',\n",
    "            'xlabel': 'Date',\n",
    "            'ylabel': 'Cumulative PnL (₹)',\n",
    "            'color': 'blue',\n",
    "            'filename': 'cumulative_return_{}.png'\n",
    "        },\n",
    "        'heatmap': {\n",
    "            'figsize': (12, 8),\n",
    "            'title': 'Monthly PnL Heatmap - {} (₹)',\n",
    "            'xlabel': 'Month',\n",
    "            'ylabel': 'Year',\n",
    "            'cmap': 'RdYlGn',\n",
    "            'filename': 'monthly_pnl_heatmap_{}.png'\n",
    "        },\n",
    "        'combined': {\n",
    "            'figsize': (12, 8),\n",
    "            'title': 'Cumulative Profit Over Time - All Stocks',\n",
    "            'xlabel': 'Date',\n",
    "            'ylabel': 'Cumulative PnL (₹)',\n",
    "            'filename': 'cumulative_return_all_stocks.png'\n",
    "        }\n",
    "    },\n",
    "    'performance_csv': 'stock_performance.csv'  # Output CSV for top/bottom stocks\n",
    "}\n",
    "\n",
    "class Plotter:\n",
    "    @staticmethod\n",
    "    def plot_cumulative_pnl(df: Optional[pl.DataFrame], name: str, config: Dict, combined: bool = False, all_dfs: Optional[List[pl.DataFrame]] = None, all_names: Optional[List[str]] = None):\n",
    "        plt.figure(figsize=config['figsize'])\n",
    "        if combined and all_dfs and all_names:\n",
    "            for df_pnl, stock_name in zip(all_dfs, all_names):\n",
    "                if df_pnl is not None and not df_pnl.is_empty():\n",
    "                    plt.plot(df_pnl['Date'].to_pandas(), df_pnl['Cumulative PnL'], label=stock_name)\n",
    "        elif df is not None and not df.is_empty():\n",
    "            plt.plot(df['Date'].to_pandas(), df['Cumulative PnL'], label=f'Cumulative PnL ({name})', color=config['color'])\n",
    "        plt.title(config['title'].format(name if not combined else 'All Stocks'))\n",
    "        plt.xlabel(config['xlabel'])\n",
    "        plt.ylabel(config['ylabel'])\n",
    "        plt.grid(True)\n",
    "        plt.legend()\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(config['filename'].format(name if not combined else 'all_stocks'))\n",
    "        plt.close()\n",
    "\n",
    "    @staticmethod\n",
    "    def plot_monthly_heatmap(df: Optional[pl.DataFrame], name: str, config: Dict):\n",
    "        if df is None or df.is_empty():\n",
    "            return\n",
    "        df = df.with_columns([\n",
    "            pl.col('Date').dt.year().alias('Year'),\n",
    "            pl.col('Date').dt.month().alias('Month')\n",
    "        ])\n",
    "        monthly_pnl = df.group_by(['Year', 'Month']).agg(pl.col('PnL').sum()).pivot(\n",
    "            values='PnL', index='Year', columns='Month', aggregate_function='sum'\n",
    "        ).fill_null(0)\n",
    "        plt.figure(figsize=config['figsize'])\n",
    "        sns.heatmap(monthly_pnl.to_pandas().iloc[:, 1:], annot=True, fmt='.2f', cmap=config['cmap'], center=0)\n",
    "        plt.title(config['title'].format(name))\n",
    "        plt.xlabel(config['xlabel'])\n",
    "        plt.ylabel(config['ylabel'])\n",
    "        plt.tight_layout()\n",
    "        plt.savefig(config['filename'].format(name))\n",
    "        plt.close()\n",
    "\n",
    "class GapStrategy(bt.Strategy):\n",
    "    params = (\n",
    "        ('capital_per_trade', CONFIG['capital_per_trade']),\n",
    "        ('min_gap_pct', CONFIG['min_gap_pct']),\n",
    "        ('circuit_limit', CONFIG['circuit_limit']),\n",
    "    )\n",
    "\n",
    "    def __init__(self):\n",
    "        self.trades = {\n",
    "            'gap_up_long': [],\n",
    "            'gap_up_short': [],\n",
    "            'gap_down_long': [],\n",
    "            'gap_down_short': []\n",
    "        }\n",
    "        self.previous_close = None\n",
    "\n",
    "    def log(self, txt: str, dt: Optional[datetime.date] = None):\n",
    "        dt = dt or self.datas[0].datetime.date(0)\n",
    "        logger.info(f'{dt}: {txt}')\n",
    "\n",
    "    def log_trade(self, date: datetime.date, trade_type: str, entry_price: float, exit_price: float, shares: int, pnl: float, gap_pct: float, gap_direction: str):\n",
    "        trade_data = {\n",
    "            'Date': date,\n",
    "            'Type': trade_type,\n",
    "            'Entry Price': entry_price,\n",
    "            'Exit Price': exit_price,\n",
    "            'Shares': shares,\n",
    "            'PnL': pnl,\n",
    "            'Gap %': gap_pct\n",
    "        }\n",
    "        key = f\"gap_{gap_direction}_{trade_type.lower()}\"\n",
    "        self.trades[key].append(trade_data)\n",
    "\n",
    "    def is_circuit(self, high: float, low: float, close: float, previous_close: float) -> bool:\n",
    "        if previous_close == 0:\n",
    "            return False\n",
    "        upper_circuit = previous_close * (1 + self.params.circuit_limit)\n",
    "        lower_circuit = previous_close * (1 - self.params.circuit_limit)\n",
    "        is_upper = abs(high - close) < 1e-6 and close >= upper_circuit\n",
    "        is_lower = abs(low - close) < 1e-6 and close <= lower_circuit\n",
    "        return is_upper or is_lower\n",
    "\n",
    "    def next(self):\n",
    "        date = self.datas[0].datetime.date(0)\n",
    "        open_price = self.datas[0].open[0]\n",
    "        high_price = self.datas[0].high[0]\n",
    "        low_price = self.datas[0].low[0]\n",
    "        close_price = self.datas[0].close[0]\n",
    "\n",
    "        if self.previous_close is None:\n",
    "            self.previous_close = close_price\n",
    "            return\n",
    "\n",
    "        gap = open_price - self.previous_close\n",
    "        gap_pct = (gap / self.previous_close * 100) if self.previous_close != 0 else 0\n",
    "        abs_gap_pct = abs(gap_pct)\n",
    "        gap_direction = 'up' if gap > 0 else 'down' if gap < 0 else 'zero'\n",
    "        shares = int(self.params.capital_per_trade / open_price) if open_price > 0 else 0\n",
    "\n",
    "        gap_info = f\"Open: {open_price:.2f}, Previous Close: {self.previous_close:.2f}\"\n",
    "\n",
    "        # Check for circuit\n",
    "        if self.is_circuit(high_price, low_price, close_price, self.previous_close):\n",
    "            self.log(f\"No trade: Circuit hit ({gap_info})\")\n",
    "            self.previous_close = close_price\n",
    "            return\n",
    "\n",
    "        if shares == 0:\n",
    "            self.log(f\"No trade: Insufficient capital ({gap_info})\")\n",
    "        elif abs_gap_pct <= self.params.min_gap_pct:\n",
    "            direction = \"Up\" if gap > 0 else \"Down\" if gap < 0 else \"Zero\"\n",
    "            self.log(f\"Gap {direction}: {gap_pct:.2f}% (too small, >{self.params.min_gap_pct}% required, {gap_info})\")\n",
    "        elif open_price == self.previous_close:\n",
    "            self.log(f\"No trade: No gap ({gap_info})\")\n",
    "        else:\n",
    "            trade_type = 'Long' if open_price > self.previous_close else 'Short'\n",
    "            direction = 'Up' if trade_type == 'Long' else 'Down'\n",
    "            self.log(f\"Gap {direction}: {gap_pct:.2f}% ({gap_info}) | {trade_type}: {shares} shares @ {open_price:.2f}, Exit @ {close_price:.2f}\")\n",
    "            \n",
    "            if trade_type == 'Long':\n",
    "                self.buy(size=shares, price=open_price)\n",
    "                self.sell(size=shares, price=close_price)\n",
    "                pnl = (close_price - open_price) * shares\n",
    "            else:\n",
    "                self.sell(size=shares, price=open_price)\n",
    "                self.buy(size=shares, price=close_price)\n",
    "                pnl = (open_price - close_price) * shares\n",
    "            \n",
    "            self.log_trade(date, trade_type, open_price, close_price, shares, pnl, gap_pct, gap_direction)\n",
    "            self.log(f\"PnL: ₹{pnl:.2f}\")\n",
    "\n",
    "        self.previous_close = close_price\n",
    "\n",
    "def analyze_stock(trades: Dict[str, List[Dict]], stock_name: str) -> Tuple[Optional[pl.DataFrame], float]:\n",
    "    all_trades = []\n",
    "    for key, trade_list in trades.items():\n",
    "        all_trades.extend(trade_list)\n",
    "\n",
    "    if not all_trades:\n",
    "        logger.info(f\"No trades executed for {stock_name}.\")\n",
    "        return None, 0.0\n",
    "\n",
    "    try:\n",
    "        df_trades = pl.DataFrame(all_trades)\n",
    "        if df_trades.is_empty():\n",
    "            return None, 0.0\n",
    "\n",
    "        total_pnl = df_trades['PnL'].sum()\n",
    "        df_trades = df_trades.with_columns([\n",
    "            pl.col('Date').cast(pl.Datetime),\n",
    "            pl.col('PnL').cum_sum().alias('Cumulative PnL')\n",
    "        ])\n",
    "\n",
    "        # Overall statistics\n",
    "        wins = df_trades.filter(pl.col('PnL') > 0).shape[0]\n",
    "        total_trades = df_trades.shape[0]\n",
    "        summary = {\n",
    "            'Total Trades': total_trades,\n",
    "            'Wins': wins,\n",
    "            'Losses': total_trades - wins,\n",
    "            'Win Rate': (wins / total_trades * 100) if total_trades > 0 else 0,\n",
    "            'Total PnL': total_pnl,\n",
    "            'Average PnL': df_trades['PnL'].mean() if total_trades > 0 else 0\n",
    "        }\n",
    "\n",
    "        # Scenario-based statistics\n",
    "        scenario_stats = {}\n",
    "        for key in trades:\n",
    "            df_scenario = pl.DataFrame(trades[key])\n",
    "            if not df_scenario.is_empty():\n",
    "                scenario_wins = df_scenario.filter(pl.col('PnL') > 0).shape[0]\n",
    "                scenario_total = df_scenario.shape[0]\n",
    "                scenario_stats[key] = {\n",
    "                    'Total Trades': scenario_total,\n",
    "                    'Wins': scenario_wins,\n",
    "                    'Losses': scenario_total - scenario_wins,\n",
    "                    'Win Rate': (scenario_wins / scenario_total * 100) if scenario_total > 0 else 0,\n",
    "                    'Total PnL': df_scenario['PnL'].sum(),\n",
    "                    'Average PnL': df_scenario['PnL'].mean() if scenario_total > 0 else 0\n",
    "                }\n",
    "\n",
    "        logger.info(f\"Trade Log for {stock_name}:\\n{df_trades[['Date', 'Type', 'Entry Price', 'Exit Price', 'Shares', 'Gap %', 'PnL']].to_pandas().to_string(index=False)}\")\n",
    "        logger.info(f\"\\nOverall Summary Statistics for {stock_name}:\")\n",
    "        for key, value in summary.items():\n",
    "            logger.info(f\"{key}: {value:.2f}\" if isinstance(value, float) else f\"{key}: {value}\")\n",
    "        \n",
    "        logger.info(f\"\\nScenario-Based Statistics for {stock_name}:\")\n",
    "        for scenario, stats in scenario_stats.items():\n",
    "            logger.info(f\"\\n{scenario.replace('_', ' ').title()}:\")\n",
    "            for key, value in stats.items():\n",
    "                logger.info(f\"{key}: {value:.2f}\" if isinstance(value, float) else f\"{key}: {value}\")\n",
    "\n",
    "        Plotter.plot_cumulative_pnl(df_trades, stock_name, CONFIG['plot_config']['cumulative'])\n",
    "        Plotter.plot_monthly_heatmap(df_trades, stock_name, CONFIG['plot_config']['heatmap'])\n",
    "\n",
    "        return df_trades[['Date', 'Cumulative PnL']], total_pnl\n",
    "    except Exception as e:\n",
    "        logger.error(f\"Error analyzing stock {stock_name}: {e}\")\n",
    "        return None, 0.0\n",
    "\n",
    "def run_backtest_for_stock(csv_file: str, config: Dict = CONFIG) -> Tuple[Optional[pl.DataFrame], str, float]:\n",
    "    stock_name = os.path.splitext(os.path.basename(csv_file))[0]\n",
    "    logger.info(f\"Processing {stock_name}...\")\n",
    "\n",
    "    try:\n",
    "        cerebro = bt.Cerebro()\n",
    "        cerebro.addstrategy(GapStrategy)\n",
    "        cerebro.broker.setcash(config['initial_cash'])\n",
    "        cerebro.broker.setcommission(commission=config['commission'])\n",
    "\n",
    "        start_date = datetime.strptime(config['start_date'], '%Y-%m-%d')\n",
    "        end_date = datetime.strptime(config['end_date'], '%Y-%m-%d')\n",
    "\n",
    "        data = bt.feeds.GenericCSVData(\n",
    "            dataname=csv_file,\n",
    "            fromdate=start_date,\n",
    "            todate=end_date,\n",
    "            nullvalue=0.0,\n",
    "            dtformat=config['date_format'],\n",
    "            datetime=0, open=1, high=2, low=3, close=4, volume=5, openinterest=-1\n",
    "        )\n",
    "        cerebro.adddata(data)\n",
    "\n",
    "        strats = cerebro.run()\n",
    "        if strats:\n",
    "            df_trades, total_pnl = analyze_stock(strats[0].trades, stock_name)\n",
    "            return df_trades, stock_name, total_pnl\n",
    "        logger.error(f\"Backtest failed for {stock_name}.\")\n",
    "        return None, stock_name, 0.0\n",
    "    except Exception as e:\n",
    "        logger.error(f\"Error in backtest for {csv_file}: {e}\")\n",
    "        return None, stock_name, 0.0\n",
    "\n",
    "def export_stock_performance(stock_pnls: List[Tuple[str, float]], config: Dict):\n",
    "    try:\n",
    "        df = pl.DataFrame({\n",
    "            'Stock': [name for name, _ in stock_pnls],\n",
    "            'Total PnL': [pnl for _, pnl in stock_pnls]\n",
    "        })\n",
    "        \n",
    "        # Top 100 profitable stocks\n",
    "        profitable = df.filter(pl.col('Total PnL') > 0).sort('Total PnL', descending=True).head(100)\n",
    "        # Top 100 loss-making stocks\n",
    "        loss_making = df.filter(pl.col('Total PnL') < 0).sort('Total PnL', descending=False).head(100)\n",
    "        \n",
    "        # Combine and save\n",
    "        combined = pl.concat([profitable, loss_making])\n",
    "        combined.write_csv(config['performance_csv'])\n",
    "        logger.info(f\"Stock performance saved to {config['performance_csv']}\")\n",
    "        \n",
    "        # Log top/bottom stocks\n",
    "        logger.info(\"\\nTop Profitable Stocks:\")\n",
    "        for row in profitable.head(5).rows(named=True):\n",
    "            logger.info(f\"{row['Stock']}: ₹{row['Total PnL']:.2f}\")\n",
    "        logger.info(\"\\nTop Loss-Making Stocks:\")\n",
    "        for row in loss_making.head(5).rows(named=True):\n",
    "            logger.info(f\"{row['Stock']}: ₹{row['Total PnL']:.2f}\")\n",
    "    except Exception as e:\n",
    "        logger.error(f\"Error exporting stock performance: {e}\")\n",
    "\n",
    "def run_multi_stock_backtest(csv_files: List[str], config: Dict = CONFIG) -> None:\n",
    "    if not csv_files:\n",
    "        logger.error(f\"No CSV files found in {config['csv_directory']}.\")\n",
    "        logger.info(f\"Current directory contents: {os.listdir(config['csv_directory'])}\")\n",
    "        return\n",
    "\n",
    "    logger.info(f\"Found {len(csv_files)} CSV files: {[os.path.basename(f) for f in csv_files]}\")\n",
    "    \n",
    "    all_pnl_dfs = []\n",
    "    stock_names = []\n",
    "    stock_pnls = []\n",
    "\n",
    "    # Sequential execution with tqdm progress bar\n",
    "    results = []\n",
    "    for csv_file in tqdm(csv_files, desc=\"Processing CSVs\", unit=\"file\"):\n",
    "        result = run_backtest_for_stock(csv_file, config)\n",
    "        results.append(result)\n",
    "\n",
    "    for df_trades, stock_name, total_pnl in results:\n",
    "        if df_trades is not None:\n",
    "            all_pnl_dfs.append(df_trades)\n",
    "            stock_names.append(stock_name)\n",
    "        stock_pnls.append((stock_name, total_pnl))\n",
    "\n",
    "    if all_pnl_dfs:\n",
    "        Plotter.plot_cumulative_pnl(None, 'all_stocks', config['plot_config']['combined'], combined=True, all_dfs=all_pnl_dfs, all_names=stock_names)\n",
    "    else:\n",
    "        logger.info(\"No valid results to plot combined PnL.\")\n",
    "\n",
    "    # Export stock performance\n",
    "    export_stock_performance(stock_pnls, config)\n",
    "\n",
    "def main():\n",
    "    sys.setprofile(None)\n",
    "    csv_files = glob.glob(os.path.join(CONFIG['csv_directory'], '*.csv'))\n",
    "    profiler = cProfile.Profile()\n",
    "    try:\n",
    "        profiler.enable()\n",
    "        run_multi_stock_backtest(csv_files)\n",
    "    except Exception as e:\n",
    "        logger.error(f\"Error during execution: {e}\")\n",
    "        raise\n",
    "    finally:\n",
    "        profiler.disable()\n",
    "        stats = pstats.Stats(profiler).sort_stats('cumulative')\n",
    "        stats.dump_stats('profile.prof')\n",
    "        stats.print_stats()\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
